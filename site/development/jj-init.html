<!doctype html>
<html lang="en">
   <head>
      <meta charset="UTF-8" />
      <meta http-equiv="X-UA-Compatible" content="IE=edge" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <title>jj init – Sympolymathesy, by Chris Krycho</title>
      <meta
         name="description"
         content="What will someday be the next version of chriskrycho.com"
      />
      <meta property="og:title" content="Under Construction – v6.chriskrycho.com" />
      <meta
         property="og:description"
         content="What will someday be the next version of chriskrycho.com"
      />
      <meta property="og:type" content="website" />
      <meta
         name="twitter:description"
         content="What will someday be the next version of chriskrycho.com"
      />
      <link rel="stylesheet" href="./style.css" media="screen" />
   </head>
   <body>
      <div class="bg padding-grid margin-grid">
         <header>
            <h1>Sym·poly·mathesy</h1>
            <h2>
               <span class="header-by">by</span>
               <span class="header-me">Chris Krycho</span>
            </h2>
         </header>

         <nav class="page-nav">
            <ul>
               <li><a href="/">/</a></li>
               <li><a href="/writing">/writing</a></li>
            </ul>
         </nav>

         <main>
            <article>
               <header class="item-header post">
                  <h1 class="item-title">jj init</h1>
                  <p class="item-subtitle">
                     What if we actually <em>could</em> replace Git? Jujutsu might give us
                     a real shot.
                  </p>
               </header>

               <div class="article-content">
                  <div class="qualifiers">
                     <p>
                        <b
                           ><a
                              href="https://v4.chriskrycho.com/2018/assumed-audiences.html"
                              >Assumed audience</a
                           >:</b
                        >
                        People who have worked with Git or other modern version control
                        systems like Mercurial, Darcs, Pijul, Bazaar, etc., and have at
                        least a basic idea of how they work.
                     </p>
                  </div>
                  <p>
                     <a href="https://github.com/martinvonz/jj#command-line-completion"
                        >Jujutsu</a
                     >
                     is a new version control system from a software engineer at Google,
                     where it is on track to replace Google’s existing version control
                     systems (historically: Perforce, Piper, and Mercurial). I find it
                     interesting both for the approach it takes and for its careful design
                     choices in terms of both implementation details and user interface.
                     It offers one possible answer to a question I first started asking
                     <a href="https://v4.chriskrycho.com/2014/next-gen-vcs.html"
                        >most of a decade ago</a
                     >:
                     <em
                        >What might a next-gen version control system look like — one
                        which actually learned from the best parts of all of this
                        generation’s systems, including Mercurial, Git, Darcs, Fossil,
                        etc.?</em
                     >
                  </p>
                  <p>
                     To answer that question, it is important to have a sense of what
                     those lessons are. This is trickier than it might seem. Git has
                     substantially the most<span class="push-double"></span>
                     <span class="pull-double">“</span>mind-share” in the current
                     generation; most software developers learn it and use it not because
                     they have done any investigation of the tool and its alternatives but
                     because it is a <em>de facto</em> standard: a situation which arose
                     in no small part because of its<span class="push-double"></span>
                     <span class="pull-double">“</span>killer app” in the form of GitHub.
                     Developers who have been around for more than a decade or so have
                     likely seen more than one version control system — but there are
                     many, <em>many</em> developers for whom Git was their first and, so
                     far, last <abbr title="version control system">VCS</abbr>.
                  </p>
                  <p>
                     The problems with Git are many, though. Most of all, its infamously
                     terrible command line interface results in a terrible user
                     experience. In my experience, very few working developers have a good
                     mental model for Git. Instead, they have a handful of commands they
                     have learned over the years: enough to get by, and little more. The
                     common rejoinder is that developers ought to learn how Git works
                     internally — that everything will make more sense that way.
                  </p>
                  <p>
                     This is nonsense. Git’s internals are <em>interesting</em> on an
                     implementation level, but frankly add up to an incoherent mess in
                     terms of a user mental model. This is a classic mistake for software
                     developers, and one I have fallen prey to myself any number of times.
                     I do not blame the Git developers for it, exactly. No one should have
                     to understand the internals of the system to use it well, though;
                     that is a simple failure of software design. Moreover, even those
                     internals do not particularly <em>cohere</em>. The index, the number
                     of things labeled<span class="push-double"></span>
                     <span class="pull-double">“</span>-ish” in the glossary, the way that
                     a<span class="push-double"></span>
                     <span class="pull-double">“</span>detached <code>HEAD</code
                     ><span class="push-double"></span
                     ><span class="pull-double">”</span> interacts with branches, the
                     distinction between tags and branches, the important distinctions
                     between commits, refs, and objects… It is not that any one of those
                     things is bad in isolation, but as a set they do not amount to a
                     mental model I can describe charitably. Put in programming language
                     terms: One of the reasons the<span class="push-double"></span>
                     <span class="pull-double">“</span>surface syntax” of Git is so hard
                     is that its semantics are a bit confused, and that
                     <em>inevitably</em> shows up in the interface to users.
                  </p>
                  <p>
                     Still, a change in a system so deeply embedded in the software
                     development ecosystem is not cheap. Is it worth the cost of adoption?
                     Well, Jujutsu has a trick up its sleeve: there is no adoption cost.
                     You just install it — <code>brew install jj</code> will do the trick
                     on macOS — and run a single command in an existing Git repository,
                     and… that’s it. (“There is no step 3.”) I expect that mode will
                     always work, even though there will be a migration step at some point
                     in the future, when Jujutsu’s own, non-Git backend becomes a
                     viable — and ultimately the recommended — option. I am getting ahead
                     of myself though. The first thing to understand is what Jujutsu is,
                     and is not.
                  </p>
                  <p>Jujutsu is two things:</p>
                  <ol>
                     <li>
                        <p>
                           <strong>It is a new front-end to Git.</strong> This is
                           <em>by far</em> the less interesting of the two things, but in
                           practice it is a substantial part of the experience of using
                           the tool today. In this regard, it sits in the same notional
                           space as something like
                           <a href="https://github.com/Byron/gitoxide">gitoxide</a>.
                           Jujutsu’s <code>jj</code> is far more usable for day to day
                           work than gitoxide’s <code>gix</code> and <code>ein</code> so
                           far, though, and it also has very different aims. That takes us
                           to:
                        </p>
                     </li>
                     <li>
                        <p>
                           <strong
                              >It is a new design for distributed version control.</strong
                           >
                           This is by far the more interesting part. In particular,
                           Jujutsu brings to the table a few key concepts — none of which
                           are themselves novel, but the combination of which is
                           <em>really</em> nice to use in practice:
                        </p>
                        <ul>
                           <li>
                              <em>Changes</em> are distinct from <em>revisions</em>: an
                              idea borrowed from Mercurial, but quite different from Git’s
                              model.
                           </li>
                           <li>
                              Conflicts are first-class items: an idea borrowed from
                              <a href="https://pijul.org">Pijul</a> and
                              <a href="https://darcs.net">Darcs</a>.
                           </li>
                           <li>
                              The user interface is not only reasonable but actually
                              <em>really good</em>: an idea borrowed from… literally every
                              <abbr>VCS</abbr> other than Git.
                           </li>
                        </ul>
                     </li>
                  </ol>
                  <p>
                     The combo of those means that you can use it today in your existing
                     Git repos, as I have been for the past six months, and that it is a
                     <em>really good</em> experience using it that way. (Better than Git!)
                     Moreover, given it is being actively developed at and by Google for
                     use as a replacement for its current custom <abbr>VCS</abbr> setup,
                     it seems like it has a good future ahead of it. Net: at a minimum you
                     get a better experience for using Git with it. At a maximum, you get
                     an incredibly smooth and shallow on-ramp to what I earnestly hope is
                     the future of version control.
                  </p>
                  <p>
                     Jujutsu is <em>not</em> trying to do every interesting thing that
                     other Git-alternative <abbr>DVCS</abbr> systems out there do. Unlike
                     <a href="https://pijul.org">Pijul</a>, for example, it does not work
                     from a theory of patches such that the order changes are applied is
                     irrelevant. However, as I noted above and show in detail below, jj
                     <em>does</em> distinguish between <em>changes</em> and
                     <em>revisions</em>, and has first-class support for conflicts, which
                     means that many of the benefits of Pijul’s handling come along
                     anyway. Unlike
                     <a href="https://fossil-scm.org/home/doc/trunk/www/index.wiki"
                        >Fossil</a
                     >, Jujutsu is also not trying to be an all-in-one tool. Accordingly:
                     It does not come with a replacement for GitHub or other such<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>forges”. It does not include bug
                     tracking. It does not support chat or a forum or a wiki. Instead, it
                     is currently aimed at just doing the base
                     <abbr title="version control system">VCS</abbr> operations well.
                  </p>
                  <p>
                     Finally, there is a thing Jujutsu is not <em>yet</em>: a standalone
                     <abbr>VCS</abbr> ready to use <em>without</em> Git. It supports its
                     own,<span class="push-double"></span>
                     <span class="pull-double">“</span>native” back end for the sake of
                     keeping that door open for future capabilities, and the test suite
                     exercises both the Git and the<span class="push-double"></span>
                     <span class="pull-double">“</span>native” back end, but the<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>native” one is not remotely ready
                     for regular use. That said, this one I do expect to see change over
                     time!
                  </p>
                  <p>
                     One of the really interesting bits about picking up Jujutsu is
                     realizing just how weirdly Git has wired your brain, and re-learning
                     how to think about how a version control system can work. It is one
                     thing to believe — very strongly, in my case! — that Git’s
                     <abbr title="user interface">UI</abbr> design is deeply janky (and
                     its underlying model just so-so); it is something else to experience
                     how much better a <abbr title="version control system">VCS</abbr>
                     <abbr title="user interface">UI</abbr> can be (even without replacing
                     the underlying model!).
                  </p>
                  <img
                     src="https://cdn.chriskrycho.com/images/unlearn.gif"
                     alt="Yoda saying “You must unlearn what you have learned.”"
                  />
                  <p>
                     Time to become a Jedi Knight. Jujutsu Knight? Jujutsu Master? Jujutsu
                     apprentice, at least. Let’s dig in!
                  </p>
                  <details>
                     <summary>Outline</summary>
                     <ul>
                        <li>
                           <a href="#using-jujutsu">Using Jujutsu</a>
                           <ul>
                              <li>
                                 <a href="#revisions-and-revsets"
                                    >Revisions and revsets</a
                                 >
                              </li>
                              <li><a href="#changes">Changes</a></li>
                              <li><a href="#split">Split</a></li>
                              <li>
                                 <a href="#first-class-conflicts"
                                    >First-class conflicts</a
                                 >
                              </li>
                              <li><a href="#changing-changes">Changing changes</a></li>
                              <li><a href="#branches">Branches</a></li>
                              <li><a href="#git-interop">Git interop</a></li>
                              <li><a href="#is-it-ready">Is it ready?</a></li>
                           </ul>
                        </li>
                        <li><a href="#conclusion">Conclusion</a></li>
                        <li>
                           <a href="#appendix-kaleidoscope-setup-and-tips"
                              >Appendix: Kaleidoscope setup and tips</a
                           >
                        </li>
                     </ul>
                  </details>
                  <h2 id="using-jujutsu" tabindex="-1">
                     <a class="header-anchor" href="#using-jujutsu">Using Jujutsu</a>
                  </h2>
                  <p>
                     That is all interesting enough philosophically, but for a tool that,
                     if successful, will end up being one of a software developer’s
                     most-used tools, there is an even more important question:
                     <em>What is it actually like to use?</em>
                  </p>
                  <p>
                     Setup is painless. Running <code>brew install jj</code> did
                     everything I needed. As with most modern Rust-powered
                     <abbr title="command line interface">CLI</abbr> tools,<sup
                        class="footnote-ref"
                        ><a href="#fn1" id="fnref1">1</a></sup
                     >
                     Jujutsu comes with great completions right out of the box. I did make
                     one post-install tweak, since I am going to be using this on existing
                     Git projects: I updated my <code>~/.gitignore_global</code> to ignore
                     <code>.jj</code> directories anywhere on disk.<sup
                        class="footnote-ref"
                        ><a href="#fn2" id="fnref2">2</a></sup
                     >
                  </p>
                  <p>
                     Using Jujutsu in an existing Git project is also quite easy.<sup
                        class="footnote-ref"
                        ><a href="#fn3" id="fnref3">3</a></sup
                     >
                     You just run <code>jj init --git-repo &lt;path to repo&gt;</code>.
                     That’s the entire flow. After that you can use <code>git</code> and
                     <code>jj</code> commands alike on the repository, and everything Just
                     Works™, right down to correctly handling
                     <code>.gitignore</code> files. I have since run
                     <code>jj init</code> in every Git repository I am actively working
                     on, and have had no issues in many months. It is also possible to
                     initialize a Jujutsu copy of a Git project <em>without</em> having an
                     existing Git repo, using <code>jj git clone</code>, which I have also
                     done, and which works well.
                  </p>
                  <figure>
                     <script
                        async=""
                        id="asciicast-635735"
                        src="https://asciinema.org/a/635735.js"
                        data-initialized="1"
                     ></script>
                     <div
                        id="asciicast-container-635735"
                        class="asciicast"
                        style="
                           display: block;
                           float: none;
                           overflow: hidden;
                           padding: 0px;
                           margin: 20px 0px;
                        "
                     >
                        <iframe
                           src="https://asciinema.org/a/635735/iframe?"
                           id="asciicast-iframe-635735"
                           name="asciicast-iframe-635735"
                           scrolling="no"
                           allowfullscreen="true"
                           style="
                              overflow: hidden;
                              margin: 0px;
                              border: 0px;
                              display: inline-block;
                              width: 100%;
                              float: none;
                              visibility: visible;
                              height: 628px;
                           "
                        ></iframe>
                     </div>
                     <figcaption>
                        Cloning <a href="https://true-myth.js.org">true-myth</a> and
                        initializing it as a Jujutsu repo
                     </figcaption>
                  </figure>
                  <p>
                     Once a project is initialized, working on it is fairly
                     straightforward, though there are some significant adjustments
                     required if you have deep-seated habits from Git!
                  </p>
                  <h3 id="revisions-and-revsets" tabindex="-1">
                     <a class="header-anchor" href="#revisions-and-revsets"
                        >Revisions and revsets</a
                     >
                  </h3>
                  <p>
                     One of the first things to wrap your head around when first coming to
                     Jujutsu is its approach to its <em>revisions</em> and
                     <em>revsets</em>, i.e.<span class="push-double"></span>
                     <span class="pull-double">“</span>sets of revision”. Revisions are
                     the fundamental elements of changes in Jujutsu, not<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>commits” as in Git.
                     <a
                        href="https://github.com/martinvonz/jj/blob/f3d6616057fb3db3f9227de3da930e319d29fcc7/docs/revsets.md"
                        >Revsets</a
                     >
                     are then expressions in a functional language for selecting a set of
                     revisions. Both the idea and the terminology are borrowed directly
                     from Mercurial, though the implementation is totally new. (Many
                     things about Jujutsu borrow from Mercurial — a decision which makes
                     me quite happy.) The vast majority of Jujutsu commands take a
                     <code>--revision</code>/<code>-r</code> command to select a revision.
                     So far that might not sound particularly different from Git’s notion
                     of commits and commit ranges, and they are indeed similar at a
                     surface level. However, the differences start showing up pretty
                     quickly, both in terms of working with revisions and in terms of how
                     revisions are a different notion of <em>change</em> than a Git
                     commit.
                  </p>
                  <p>
                     The first place you are likely to experience how revisions and
                     revsets are different — and neat! — is with the
                     <code>log</code> command, since looking at the commit log is likely
                     to be something you do pretty early in using a new version control
                     tool. (Certainly it was for me.) When you clone a repo and initialize
                     Jujutsu in it and then run <code>jj log</code>, you will see
                     something rather different from what <code>git log</code> would show
                     you — indeed, rather different from anything I even know
                     <em>how</em> to get <code>git log</code> to show you. For example,
                     here’s what I see today when running <code>jj log</code> on the
                     Jujutsu repository, limiting it to show just the last 10 revisions:
                  </p>
                  <pre><code>&gt; jj log --limit 10
@  ukvtttmt hello@chriskrycho.com 2024-02-03 09:37:24.000 -07:00 1a0b8773
│  (empty) (no description set)
◉  qppsqonm essiene@google.com 2024-02-03 15:06:09.000 +00:00 main* HEAD@git bcdb9beb
·  cli: Move git_init() from init.rs to git.rs
· ◉  rzwovrll ilyagr@users.noreply.github.com 2024-02-01 14:25:17.000 -08:00
┌─┘  ig/contributing@origin 01e0739d
│    Update contributing.md
◉  nxskksop 49699333+dependabot[bot]@users.noreply.github.com 2024-02-01 08:56:08.000
·  -08:00 fb6c834f
·  cargo: bump the cargo-dependencies group with 3 updates
· ◉  tlsouwqs jonathantanmy@google.com 2024-02-02 21:26:23.000 -08:00
· │  jt/missingop@origin missingop@origin 347817c6
· │  workspace: recover from missing operation
· ◉  zpkmktoy jonathantanmy@google.com 2024-02-02 21:16:32.000 -08:00 2d0a444e
· │  workspace: inline is_stale()
· ◉  qkxullnx jonathantanmy@google.com 2024-02-02 20:58:21.000 -08:00 7abf1689
┌─┘  workspace: refactor for_stale_working_copy
◉  yyqlyqtq yuya@tcha.org 2024-01-31 09:40:52.000 +09:00 976b8012
·  index: on reinit(), delete all segment files to save disk space
· ◉  oqnvqzzq martinvonz@google.com 2024-01-23 10:34:16.000 -08:00
┌─┘  push-oznkpsskqyyw@origin 54bd70ad
│    working_copy: make reset() take a commit instead of a tree
◉  rrxuwsqp stephen.g.jennings@gmail.com 2024-01-23 08:59:43.000 -08:00 57d5abab
·  cli: display which file's conflicts are being resolved
           </code></pre>
                  <p>
                     Here’s the output for the same basic command in Git — note that I am
                     not trying to get a <em>similar</em> output from Git, just asking
                     what it shows by default (and warning: wall of log output!):
                  </p>
                  <pre><code>&gt; git log -10
commit: bcdb9beb6ce5ba625ae73d4839e4574db3d9e559     HEAD -&gt; main, origin/main
date:   Mon, 15 Jan 2024 22:31:33 +0000
author: Essien Ita Essien <essiene@gmail.com>

  cli: Move git_init() from init.rs to git.rs

  * Move git_init() to cli/src/commands/git.rs and call it from there.
  * Move print_trackable_remote_branches into cli_util since it's not git specific,
    but would apply to any backend that supports remote branches.
  * A no-op change. A follow up PR will make use of this.

commit: 31e4061bab6cfc835e8ac65d263c29e99c937abf
date:   Mon, 8 Jan 2024 10:41:07 +0000
author: Essien Ita Essien <essiene@gmail.com>

  cli: Refactor out git_init() to encapsulate all git related work.

  * Create a git_init() function in cli/src/commands/init.rs where all git related work is done.
    This function will be moved to cli/src/commands/git.rs in a subsequent PR.

commit: 8423c63a0465ada99c81f87e06f833568a22cb48
date:   Mon, 8 Jan 2024 10:41:07 +0000
author: Essien Ita Essien <essiene@gmail.com>

  cli: Refactor workspace root directory creation

  * Add file_util::create_or_reuse_dir() which is needed by all init
    functionality regardless of the backend.

commit: b3c47953e807bef202d632c4e309b9a8eb814fde
date:   Wed, 31 Jan 2024 20:53:23 -0800
author: Ilya Grigoriev <ilyagr@users.noreply.github.com>

  config.md docs: document `jj config edit` and `jj config path`

  This changes the intro section to recommend using `jj config edit` to
  edit the config instead of looking for the files manually.

commit: e9c482c0176d5f0c0c28436f78bd6002aa23a5e2
date:   Wed, 31 Jan 2024 20:53:23 -0800
author: Ilya Grigoriev <ilyagr@users.noreply.github.com>

  docs: mention in `jj help config edit` that the command can create a file


commit: 98948554f72d4dc2d5f406da36452acb2868e6d7
date:   Wed, 31 Jan 2024 20:53:23 -0800
author: Ilya Grigoriev <ilyagr@users.noreply.github.com>

  cli `jj config`: add `jj config path` command


commit: 8a4b3966a6ff6b9cc1005c575d71bfc7771bced1
date:   Fri, 2 Feb 2024 22:08:00 -0800
author: Ilya Grigoriev <ilyagr@users.noreply.github.com>

  test_global_opts: make test_version just a bit nicer when it fails


commit: 42e61327718553fae6b98d7d96dd786b1f050e4c
date:   Fri, 2 Feb 2024 22:03:26 -0800
author: Ilya Grigoriev <ilyagr@users.noreply.github.com>

  test_global_opts: extract --version to its own test


commit: 42c85b33c7481efbfec01d68c0a3b1ea857196e0
date:   Fri, 2 Feb 2024 15:23:56 +0000
author: github-actions[bot] &lt;41898282+github-actions[bot]@users.noreply.github.com&gt;

  cargo: bump the cargo-dependencies group with 1 update

  Bumps the cargo-dependencies group with 1 update: [tokio](https://github.com/tokio-rs/tokio).


  Updates `tokio` from 1.35.1 to 1.36.0
  - [Release notes](https://github.com/tokio-rs/tokio/releases)
  - [Commits](https://github.com/tokio-rs/tokio/compare/tokio-1.35.1...tokio-1.36.0)

  ---
  updated-dependencies:
  - dependency-name: tokio
    dependency-type: direct:production
    update-type: version-update:semver-minor
    dependency-group: cargo-dependencies
  ...

  Signed-off-by: dependabot[bot] <support@github.com>
commit: 32c6406e5f04d2ecb6642433b0faae2c6592c151
date:   Fri, 2 Feb 2024 15:22:21 +0000
author: github-actions[bot] &lt;41898282+github-actions[bot]@users.noreply.github.com&gt;

  github: bump the github-dependencies group with 1 update

  Bumps the github-dependencies group with 1 update: [DeterminateSystems/magic-nix-cache-action](https://github.com/determinatesystems/magic-nix-cache-action).


  Updates `DeterminateSystems/magic-nix-cache-action` from 1402a2dd8f56a6a6306c015089c5086f5e1ca3ef to eeabdb06718ac63a7021c6132129679a8e22d0c7
  - [Release notes](https://github.com/determinatesystems/magic-nix-cache-action/releases)
  - [Commits](https://github.com/determinatesystems/magic-nix-cache-action/compare/1402a2dd8f56a6a6306c015089c5086f5e1ca3ef...eeabdb06718ac63a7021c6132129679a8e22d0c7)

  ---
  updated-dependencies:
  - dependency-name: DeterminateSystems/magic-nix-cache-action
    dependency-type: direct:production
    dependency-group: github-dependencies
  ...

  Signed-off-by: dependabot[bot] <support@github.com>
</support@github.com><!--41898282+github-actions[bot]@users.noreply.github.com--></support@github.com><!--41898282+github-actions[bot]@users.noreply.github.com--></ilyagr@users.noreply.github.com></ilyagr@users.noreply.github.com></ilyagr@users.noreply.github.com></ilyagr@users.noreply.github.com></ilyagr@users.noreply.github.com></essiene@gmail.com></essiene@gmail.com></essiene@gmail.com></code></pre>
                  <p>
                     What’s happening in the Jujutsu log output? Per
                     <a href="https://martinvonz.github.io/jj/v0.13.0/tutorial/"
                        >the tutorial</a
                     ><span class="push-single"></span><span class="pull-single">’</span>s
                     note on the <code>log</code> command specifically:
                  </p>
                  <blockquote>
                     <p>
                        By default, <code>jj log</code> lists your local commits, with
                        some remote commits added for context. The
                        <code>~</code> indicates that the commit has parents that are not
                        included in the graph. We can use the <code>-r</code> flag to
                        select a different set of revisions to list.
                     </p>
                  </blockquote>
                  <p>
                     What <code>jj log</code> <em>does</em> show by default was still a
                     bit non-obvious to me, even after that. <em>Which</em> remote commits
                     added for context, and why? The answer is in the
                     <code>help</code> output for <code>jj log</code
                     ><span class="push-single"></span><span class="pull-single">’</span>s
                     <code>-r</code>/<code>--revisions</code>
                     option:
                  </p>
                  <blockquote>
                     <p>
                        Which revisions to show. Defaults to the
                        <code>ui.default-revset</code> setting, or
                        <code
                           >@ | ancestors(immutable_heads().., 2) |
                           heads(immutable_heads())</code
                        >
                        if it is not set
                     </p>
                  </blockquote>
                  <p>
                     I will come back to this revset in a moment to explain it in detail.
                     First, though, this shows a couple other interesting features of
                     Jujutsu’s approach to revsets and thus the <code>log</code> command.
                     First, it treats some of these operations as
                     <em>functions</em> (<code>ancestors()</code>,
                     <code>immutable_heads()</code>, etc.). There is a whole list
                     <a
                        href="https://github.com/martinvonz/jj/blob/main/docs/revsets.md#functions"
                        >of these functions</a
                     >! This is not a surprise if you think about what<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>expressions in a functional
                     language” implies… but it was a surprise to me because I had not yet
                     read that bit of documentation. Second, it makes<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>operators”
                     <a
                        href="https://github.com/martinvonz/jj/blob/main/docs/revsets.md#operators"
                        >a first-class idea</a
                     >. Git <em>has</em> operators, but this goes a fair bit further:
                  </p>
                  <ul>
                     <li>
                        <p>
                           It includes <code>-</code> for the parent and
                           <code>+</code> for a child, and these stack and compose, so
                           writing <code>@-+-+</code> is the same as <code>@</code> as
                           long as the history is linear. (<a
                              href="https://github.com/martinvonz/jj/discussions/1905#discussioncomment-6533386"
                              >That is an important distinction!</a
                           >)
                        </p>
                     </li>
                     <li>
                        <p>
                           It supports union <code>|</code>, intersection
                           <code>&amp;</code>, and difference <code>~</code> operators.
                        </p>
                     </li>
                     <li>
                        <p>
                           A leading <code>::</code>, which means<span
                              class="push-double"
                           ></span>
                           <span class="pull-double">“</span>ancestors”. A trailing
                           <code>::</code> means<span class="push-double"></span>
                           <span class="pull-double">“</span>descendants”. Using
                           <code>::</code> between commits gives a view of the directed
                           acyclic graph range between two commits. Notably,
                           <code>&lt;id1&gt;::&lt;id2&gt;</code> is just
                           <code>&lt;id1&gt;:: &amp; ::&lt;id2&gt;</code>.
                        </p>
                     </li>
                     <li>
                        <p>
                           There is also a <code>..</code> operator, which also composes
                           appropriately (and, smartly, is the same as <code>..</code> in
                           Git when used between two commits,
                           <code>&lt;id1&gt;..&lt;id2&gt;</code>). The trailing version,
                           <code>&lt;id&gt;..</code>, is interesting: it is<span
                              class="push-double"
                           ></span>
                           <span class="pull-double">“</span>revisions that are not
                           ancestors of <code>&lt;id&gt;</code
                           ><span class="push-double"></span
                           ><span class="pull-double">”</span>. Likewise, the leading
                           version <code>..&lt;id&gt;</code> is all revisions which
                           <em>are</em> ancestors of <code>&lt;id&gt;</code>
                        </p>
                     </li>
                  </ul>
                  <p>
                     Now, I used <code>&lt;id&gt;</code> here, but throughout these
                     actually operate on revsets, so you could use them with any revset.
                     For example, <code>..tags()</code> will give you the ancestors of all
                     tags. This strikes me as <em>extremely</em> interesting: I think it
                     will dodge a lot of pain in dealing with Git histories, because it
                     lets you ask questions about the history in a compositional way using
                     normal set logic. To make that concrete: back in October, Jujutsu
                     contributor @aseipp
                     <a
                        href="https://discord.com/channels/968932220549103686/969291218347524238/1169016692651864144"
                        >pointed out</a
                     >
                     how easy it is to use this to get a log which excludes
                     <code>gh-pages</code>. (Anyone who has worked on a repo with a
                     <code>gh-pages</code> branch knows how annoying it is to have it
                     cluttering up your view of the rest of your Git history!) First, you
                     define an alias for the revset that only includes the
                     <code>gh-pages</code> branch:
                     <code>'gh-pages' = 'remote_branches(exact:"gh-pages")'</code>. Then
                     you can <em>exclude</em> it from other queries with the
                     <code>~</code> negation operator:
                     <code>jj log -r "all() ~ ancestors(gh-pages)"</code> would give you a
                     log view for every revision with <code>all()</code> and then exclude
                     every ancestor of the <code>gh-pages</code> branch.
                  </p>
                  <p>
                     Jujutsu also provides a really capable
                     <a href="https://martinvonz.github.io/jj/v0.10.0/templates/"
                        >templating system</a
                     >, which uses<span class="push-double"></span>
                     <span class="pull-double">“</span>a functional language to customize
                     output of commands”. That functional language is built on top of the
                     functional language that the whole language uses for describing
                     revisions (described in brief above!), so you can use the same kinds
                     of operators in templates for output as you do for navigating and
                     manipulating the repository. The template format is still evolving,
                     but you can use it to customize the output today… while being aware
                     that you may have to update it in the future. Keywords include things
                     like <code>description</code> and <code>change_id</code>, and these
                     can be customized in Jujutsu’s config. For example, I made this tweak
                     to mine, overriding the built-in <code>format_short_id</code> alias:
                  </p>
                  <pre><code class="language-toml"><span class="hljs-section">[template-aliases]</span>
           <span class="hljs-attr">'format_short_id(id)'</span> = <span class="hljs-string">'id.shortest()'</span>
           </code></pre>
                  <p>
                     This gives me super short names for changes and commits, which makes
                     for a <em>much</em> nicer experience when reading and working with
                     both in the log output: Jujutsu will give me the shortest unique
                     identifier for a given change or commit, which I can then use with
                     commands like <code>jj new</code>. Additionally, there are a number
                     of built-in templates. For example, to see the equivalent of Git’s
                     <code>log --pretty</code> you can use Jujutsu’s
                     <code>log -T builtin_log_detailed</code> (<code>-T</code> for<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>template”; you can also use the
                     long from <code>--template</code>). You can define your own templates
                     in a <code>[templates]</code> section, or add your own
                     <code>[template-aliases]</code> block, using the template language
                     and any combination of further functions you define yourself.
                  </p>
                  <p>
                     That’s all well and good, but even with reading the docs for the
                     revset language and the templating language, it still took me a bit
                     to actually quite make sense out of the default output, much less to
                     get a handle on how to customize the output. Right now, the docs have
                     a bit of a flavor of
                     <i
                        >explanations for people who already have a pretty good handle on
                        version control systems</i
                     >, and the description of what you get from <code>jj log</code> is a
                     good example of that. As the project gains momentum, it will need
                     other kinds of more-introductory material, but the current status is
                     totally fair and reasonable for the stage the project is at. And, to
                     be fair to Jujutsu, both the revset language and the templating
                     language are <em>incredibly</em> easier to understand and work with
                     than the corresponding Git materials.
                  </p>
                  <p>
                     Returning to the difference between the default output from
                     <code>jj log</code> and <code>git log</code>, the key is that unless
                     you pass <code>-r</code>, Jujutsu uses the
                     <code>ui.default-revset</code> selector to provide a much more
                     informative view than <code>git log</code> does. Again, the default
                     is
                     <code
                        >@ | ancestors(immutable_heads().., 2) |
                        heads(immutable_heads())</code
                     >. Walking through that:
                  </p>
                  <ul>
                     <li>
                        The <code>@</code> operator selects the current head revision.
                     </li>
                     <li>
                        The <code>|</code> union operator says<span
                           class="push-double"
                        ></span>
                        <span class="pull-double">“</span>or this other revset”, so this
                        will show <code>@</code> itself <em>and</em> the result of the
                        other two queries.
                     </li>
                     <li>
                        The <code>immutable_heads()</code> function gets the list of head
                        revisions which are, well,
                        <a
                           href="https://martinvonz.github.io/jj/v0.13.0/config/#set-of-immutable-commits"
                           >immutable</a
                        >. By default, this is <code>trunk() | tags()</code>, so whatever
                        the trunk branch is (most commonly <code>main</code> or
                        <code>master</code>) and also any tags in the repository.
                     </li>
                     <li>
                        Adding <code>..</code> to the first
                        <code>immutable_heads()</code> function selects revisions which
                        are not ancestors of those immutable heads. This is basically
                        asking for branches which are not the trunk and which do not end
                        at a tag.
                     </li>
                     <li>
                        Then <code>ancestors(immutable_heads().., 2)</code> requests the
                        ancestors of those branches, but only two deep.
                     </li>
                     <li>
                        Finally, <code>heads()</code> gets the tips of all branches which
                        appear in the revset passed to it: a head is a commit with no
                        children. Thus, <code>heads(immutable_heads())</code> gets
                        <em>just</em> the branch tips for the list of revisions computed
                        by <code>immutable_heads()</code>.<sup class="footnote-ref"
                           ><a href="#fn4" id="fnref4">4</a></sup
                        >
                     </li>
                  </ul>
                  <p>
                     When you put those all together, your log view will always show your
                     current head change, all the open branches which have not been merged
                     into your trunk branch, and whatever you have configured to be
                     immutable — out of the box, trunk and all tags. That is
                     <em>vastly</em> more informative than <code>git log</code
                     ><span class="push-single"></span><span class="pull-single">’</span>s
                     default output, even if it is a bit surprising the first time you see
                     it. Nor is it particularly possible to get that in a single
                     <code>git log</code> command. By contrast, getting the equivalent of
                     <code>git log</code> is trivial.
                  </p>
                  <p>
                     To show the full history for a given change, you can use the
                     <code>::</code> ancestors operator. Since <code>jj log</code> always
                     gives you the identifier for a revision, you can follow it up with
                     <code>jj log --revision ::&lt;change id&gt;</code>, or
                     <code>jj log -r ::&lt;change id&gt;</code> for short. For example, in
                     one repo where I am trying this, the most recent commit identifier
                     starts with <code>mwoq</code> (Jujutsu helpfully highlights the
                     segment of the change identifier you need to use), so I could write
                     <code>jj log -r ::mwoq</code>, and this will show all the ancestors
                     of <code>mwoq</code>, or <code>jj log -r ..mwoq</code> to get all the
                     ancestors of the commit except the root. (The root is uninteresting.)
                     Net, the equivalent command for<span class="push-double"></span>
                     <span class="pull-double">“</span>show me all the history for this
                     commit” is:
                  </p>
                  <pre><code class="language-sh">$ jj <span class="hljs-built_in">log</span> -r ..@
           </code></pre>
                  <p>
                     Revsets are very powerful, very flexible, and yet much easier to use
                     than Git’s operators. That is in part because of the language used to
                     express them. It is also in part because revsets build on a
                     fundamentally different view of the world than Git commits: Jujutsu’s
                     idea of <em>changes</em>.
                  </p>
                  <h3 id="changes" tabindex="-1">
                     <a class="header-anchor" href="#changes">Changes</a>
                  </h3>
                  <p>
                     In Git, as in Subversion and Mercurial and other version control
                     systems before them, when you finish with a change, you
                     <em>commit</em> it. In Jujutsu, there is no first-class notion
                     of<span class="push-double"></span>
                     <span class="pull-double">“</span>committing” code. This took me a
                     fair bit to wrap my head around! Instead, Jujutsu has two discrete
                     operations: <code>describe</code> and <code>new</code>.
                     <code>jj describe</code> lets you provide a descriptive message for
                     any change. <code>jj new</code> starts a new change. You can think of
                     <code>git commit --message "something I did"</code> as being
                     equivalent to
                     <code>jj describe --message "some I did" &amp;&amp; jj new</code>.
                     This falls out of the fact that <code>jj describe</code> and
                     <code>jj new</code> are orthogonal, and much more capable than
                     <code>git commit</code> as a result.
                  </p>
                  <p>
                     The <code>describe</code> command works on <em>any</em> commit. It
                     defaults to the commit that is the current working copy. If you want
                     to rewrite a message earlier in your commit history, though, that is
                     not a special operation like it is in Git, where you have to perform
                     an interactive rebase to do it. You just call
                     <code>jj describe</code> with a <code>--revision</code> (or
                     <code>-r</code> for short, as everywhere in Jujutsu) argument. For
                     example:
                  </p>
                  <pre><code class="language-sh"><span class="hljs-comment"># long version</span>
           $ jj describe --revision abcd --message <span class="hljs-string">"An updated message."</span>

           <span class="hljs-comment"># short version</span>
           $ jj describe -r abcd -m <span class="hljs-string">"An updated message."</span>
           </code></pre>
                  <p>
                     That’s it. How you choose to integrate that into your workflow is a
                     matter for you and your team to decide, of course. Jujutsu
                     understands that some branches should not have their history
                     rewritten this way, though, and lets you specify what the<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>immutable heads” revset should be
                     accordingly. This actually makes it safer than Git, where the tool
                     itself does not understand that kind of immutability and we rely on
                     forges to protect certain branches from being targeted by a force
                     push.
                  </p>
                  <p>
                     The <code>new</code> command is the core of creating any new change,
                     and it does not require there to be only a single parent. You can
                     create a new change with as many parents as is appropriate! Is a
                     given change logically the child of four other changes, with
                     identifiers <code>a</code>, <code>b</code>, <code>c</code>, and
                     <code>d</code>? <code>jj new a b c d</code>. That’s it. One neat
                     consequence that falls out of this: a merge in Jujutsu is just
                     <code>jj new</code> with the requirement that it have at least two
                     parents. (“At least two parents” because having multiple parents for
                     a merge is not a special case as with Git’s<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>octopus” merges.) Likewise, you do
                     not need a <code>commit</code> command, because you can describe a
                     given change at any time with <code>describe</code>, and you can
                     create a new change at any time with <code>new</code>. If you already
                     know the next thing you are going to do, you can even describe it by
                     passing <code>-m</code>/<code>--message</code> to
                     <code>new</code> when creating the new change!<sup
                        class="footnote-ref"
                        ><a href="#fn5" id="fnref5">5</a></sup
                     >
                  </p>
                  <figure>
                     <script
                        async=""
                        id="asciicast-635739"
                        src="https://asciinema.org/a/635739.js"
                        data-initialized="1"
                     ></script>
                     <div
                        id="asciicast-container-635739"
                        class="asciicast"
                        style="
                           display: block;
                           float: none;
                           overflow: hidden;
                           padding: 0px;
                           margin: 20px 0px;
                        "
                     >
                        <iframe
                           src="https://asciinema.org/a/635739/iframe?"
                           id="asciicast-iframe-635739"
                           name="asciicast-iframe-635739"
                           scrolling="no"
                           allowfullscreen="true"
                           style="
                              overflow: hidden;
                              margin: 0px;
                              border: 0px;
                              display: inline-block;
                              width: 100%;
                              float: none;
                              visibility: visible;
                              height: 628px;
                           "
                        ></iframe>
                     </div>
                     <figcaption>
                        A demo of using <code>jj new</code> to create a three-parent merge
                     </figcaption>
                  </figure>
                  <p>
                     Most of the time with Git, I am doing one of two things when I go to
                     commit a change:
                  </p>
                  <ul>
                     <li>
                        Committing everything that is in my working copy:
                        <code>git commit --all</code
                        ><sup class="footnote-ref"><a href="#fn6" id="fnref6">6</a></sup>
                        is an <em>extremely</em> common operation for me.
                     </li>
                     <li>
                        Committing a subset of it, not by using Git’s <code>-p</code> to
                        do it via that atrocious interface, but instead opening
                        <a href="https://git-fork.com">Fork</a> and doing it with Fork’s
                        staging <abbr>UI</abbr>.
                     </li>
                  </ul>
                  <p>
                     In the first case, Jujutsu’s choice to skip Git’s<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>index” looks like a very good one.
                     In the second case, I was initially skeptical. Once I got the hang of
                     working this way, though, I started to come around. My workflow with
                     <a href="https://git-fork.com">Fork</a> looks an <em>awful</em> lot
                     like the workflow that Jujutsu pushes you toward with actually using
                     a diff tool. With Jujutsu, though, <em>any</em> diff tool can work.
                     Want to use Vim?
                     <a
                        href="https://gist.github.com/ilyagr/5d6339fb7dac5e7ab06fe1561ec62d45"
                        >Go for it.</a
                     >
                  </p>
                  <p>
                     What is more, Jujutsu’s approach to the working copy results in a
                     <em>really</em> interesting shift. In every version control system I
                     have worked with previously (including
                     <a href="https://cvs.nongnu.org"
                        ><abbr title="Concurrent Versions System">CVS</abbr></a
                     >,
                     <a href="https://en.wikipedia.org/wiki/PVCS"
                        ><abbr
                           title="PVCS  Version Manager, originally Polytron Version Control System"
                           >PVCS</abbr
                        ></a
                     >,
                     <a href="https://subversion.apache.org"
                        ><abbr title="Subversion">SVN</abbr></a
                     >), the workflow has been some variation on:
                  </p>
                  <ul>
                     <li>Make a bunch of changes.</li>
                     <li>Create a commit and write a message to describe it.</li>
                  </ul>
                  <p>
                     With both Mercurial and Git, it also became possible to rewrite
                     history in various ways. I use Git’s
                     <code>rebase --interactive</code> command <em>extensively</em> when
                     working on large sets of changes. (I did the same with Mercurial’s
                     history rewriting when I was using it a decade ago.) That expanded
                     the list of common operations to include two more:
                  </p>
                  <ul>
                     <li>
                        Possibly directly amend that set of changes and/or its
                        description.
                     </li>
                     <li>
                        Possibly restructure history: breaking apart changes, reordering
                        them, rewriting their message, changing what commit they land on
                        top of, and more.
                     </li>
                  </ul>
                  <p>
                     Jujutsu flips all of that on its head. A <em>change</em>, not a
                     <em>commit</em>, is the fundamental element of the mental and working
                     model. That means that you can describe a change that is still<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>in progress” as it were. I
                     discovered this while working on a little example code for a blog
                     post I plan to publish later this month: you can describe the change
                     you are working on <em>and then keep working on it</em>. The act of
                     describing the change is distinct from the act of<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>committing” and thus starting a
                     <em>new</em> change. This falls out naturally from the fact that the
                     working copy state is something you can operate on directly: akin to
                     Git’s index, but without its many pitfalls. (This simplification
                     affects a lot of things, as I will discuss further below; but it is
                     especially important for new learners. Getting my head around the
                     index was one of those things I found quite challenging initially
                     with Git a decade ago.)
                  </p>
                  <p>
                     When you are ready to start a new change, you use either
                     <code>jj commit</code> to<span class="push-double"></span>
                     <span class="pull-double">“</span>finalize” this commit with a
                     message, or <code>jj new</code> to<span class="push-double"></span>
                     <span class="pull-double">“</span>Create a new, empty change and edit
                     it in the working copy”. Implied: <code>jj commit</code> is just a
                     convenience for <code>jj describe</code> followed by
                     <code>jj new</code>. And a bonus: this means that rewording a message
                     earlier in history does not involve some kind of rebase operation;
                     you just <code>jj describe --revision &lt;target&gt;</code>.
                  </p>
                  <p>
                     What is more, <code>jj new</code> lets you create a new commit
                     anywhere in the history of your project, trivially:
                  </p>
                  <pre><code>-A, --insert-after
                 Insert the new change between the target commit(s) and their children

                 [aliases: after]

           -B, --insert-before
                 Insert the new change between the target commit(s) and their parents

                 [aliases: before]
           </code></pre>
                  <p>
                     You can do this using interactive rebasing with Git (or with history
                     rewriting with Mercurial, though I am afraid my <code>hg</code> is
                     rusty enough that I do not remember the details). What you cannot do
                     in Git specifically is say<span class="push-double"></span>
                     <span class="pull-double">“</span>Start a new change at point
                     <em>x</em><span class="push-double"></span
                     ><span class="pull-double">”</span> unless you are in the middle of a
                     rebase operation, which makes it inherently somewhat fragile. To be
                     extra clear: Git allows you to check out make a new change at any
                     point in your graph, but it creates a branch at that point, and none
                     of the descendants of that original point in your commit graph will
                     come along without explicitly rebasing. Moreover, even once you do an
                     explicit rebase and cherry-pick in the commit, the original commit is
                     still hanging out, so you likely need to delete that branch. With
                     <code>jj new -A &lt;some change ID&gt;</code>, you just insert the
                     change directly into the history. Jujutsu will rebase every child in
                     the history, including any merges if necessary; it<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>just works”. That does not
                     guarantee you will not have conflicts, of course, but Jujutsu also
                     handles conflicts better — way better — than Git. More on that below.
                  </p>
                  <p>
                     I never use <code>git reflog</code> so much as when doing interactive
                     rebases. Once I got the hang of Jujutsu’s ability to
                     <code>jj new</code> anywhere, it basically obviates most of the
                     places I have needed Git’s interactive rebase mode, especially when
                     combined with Jujutsu’s aforementioned support for<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>first-class conflicts”. There
                     <em>is</em> still an escape hatch for mistakes, though:
                     <code>jj op log</code> shows all the operations you have performed on
                     the repo — and frankly, is much more useful and powerful than
                     <code>git reflog</code>, because it logs <em>all</em> the operations,
                     including whenever Jujutsu updates its view of your working copy via
                     <code>jj status</code>, when it fetches new revisions from a remote.
                  </p>
                  <p>
                     Additionally, Jujutsu allows you to see how any change has evolved
                     over time. This handily solves multiple pain points in Git. For
                     example, if you have made changes in your working copy, and would
                     like to split it into multiple changes, Git only has a binary state
                     to let you tease those apart: staged, or not. As a result, that kind
                     of operation ranges in difficulty from merely painful to outright
                     impossible. With its
                     <code>obslog</code> command,<sup class="footnote-ref"
                        ><a href="#fn7" id="fnref7">7</a></sup
                     >
                     Jujutsu allows you to see how a change has evolved over time. Since
                     the working copy is just one more kind of<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>change”, you can very easily
                     <a
                        href="https://github.com/martinvonz/jj/blob/3d0b3d57d82c5fe77527704d008256b7d995209c/docs/FAQ.md#i-accidentally-amended-the-working-copy-how-do-i-move-the-new-changes-into-its-own-commit"
                        >retrieve</a
                     >
                     earlier state — any time you did a <code>jj status</code> check, or
                     any other command which snapshotted the state of the repository
                     (which is most of them). That applies equally to earlier changes. If
                     you just rebased, for example, and realize you moved some changes to
                     code into the wrong revision, you can use the combination of
                     <code>obslog</code> and <code>new</code> and <code>restore</code> (or
                     <code>move</code>) to pull it back apart into the desired sequence of
                     changes. (This one is hard to describe, so I may put up a video of it
                     later!)
                  </p>
                  <h3 id="split" tabindex="-1">
                     <a class="header-anchor" href="#split">Split</a>
                  </h3>
                  <p>
                     This also leads to another significant difference with Git: around
                     breaking up your current set of changes on disk. As I noted above,
                     Jujutsu treats the working copy itself as a commit instead of having
                     an<span class="push-double"></span>
                     <span class="pull-double">“</span>index” like Git. Git really
                     <em>only</em> lets you break apart a set of changes with the index,
                     using <code>git add --patch</code>. Jujutsu instead has a
                     <code>split</code> command, which launches a diff editor and lets you
                     select what you want to incorporate — rather like
                     <code>git add --patch</code> does. As with all of its commands,
                     though, <code>jj split</code> works exactly the same way on
                     <em>any</em> commit; the working copy commit gets it<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>for free”.
                  </p>
                  <p>
                     Philosophically, I really like this. Practically, though, it is a
                     slightly bumpier experience for me than the Git approach at the
                     moment. Recall that I do not use
                     <code>git add --patch</code> directly. Instead, I always stage
                     changes into the Git index using a graphical tool like
                     <a href="https://git-fork.com">Fork</a>. That workflow is slightly
                     nicer than editing a diff — at least, as Jujutsu does it today. In
                     Fork (and similar tools), you start with <em>no</em> changes and add
                     what you want to the change set you want. By contrast,
                     <code>jj split</code> launches a diff view with <em>all</em> the
                     changes from a given commit present: splitting the commit involves
                     <em>removing</em> changes from the right side of the diff so that it
                     has only the changes you want to be present in the first of two new
                     commits; whatever is <em>not</em> present in the final version of the
                     right side when you close your diff editor ends up in the second
                     commit.
                  </p>
                  <p>
                     If this sounds a little complicated, that is because it is — at least
                     for today. That qualifier is important, because a lot of this is down
                     to tooling, and we have about as much dedicated tooling for Jujutsu
                     as Git had in 2007, which is to say: not much. Qualifier
                     notwithstanding, and philosophical elegance notwithstanding, the
                     complexity is still real here in early 2024. There are two big
                     downsides as things stand. First, I find it comes with more cognitive
                     load. It requires thinking in terms of negation rather than addition,
                     and the<span class="push-double"></span>
                     <span class="pull-double">“</span>second commit” becomes less and
                     less visible over time as you remove it from the first commit.
                     Second, it requires you to repeat the operation when breaking up
                     something into more than two commits. I semi-regularly take a single
                     bucket of changes on disk and chunk it up into <em>many</em> more
                     than just 2 commits, though! That significantly multiplies the
                     cognitive overhead.
                  </p>
                  <p>
                     Now, since I started working with Jujutsu, the team has switched the
                     default view for working with these kinds of diffs to using
                     <code>scm-diff-editor</code>, a
                     <abbr title="textual user interface">TUI</abbr> which has a
                     first-class notion of this kind of workflow.<sup class="footnote-ref"
                        ><a href="#fn8" id="fnref8">8</a></sup
                     >
                     That <abbr>TUI</abbr> works reasonably well, but is much less
                     pleasant to use than something like the nice <abbr>GUI</abbr>s of
                     <a href="https://git-fork.com">Fork</a> or
                     <a href="https://www.git-tower.com/mac">Tower</a>.
                  </p>
                  <p>
                     The net is: when I want to break apart changes, at least for the
                     moment I find myself quite tempted to go back to Fork and Git’s
                     index. I do not think this problem is intractable, and I think the
                     <em>idea</em> of <code>jj split</code> is right. It
                     just — “just”! — needs some careful design work. Preferably, the
                     <code>split</code> command would make it straightforward to generate
                     an arbitrary number of commits from one initial commit, and it would
                     allow progressive creation of each commit from a<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>vs. the previous commit” baseline.
                     This is the upside of the index in Git: it does actually reflect the
                     reality that there are three separate<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>buckets” in view when splitting
                     apart a change: the baseline before all changes, the set of all the
                     changes, and the set you want to include in the commit. Existing diff
                     tools do not really handle this — other than the integrated
                     index-aware diff tools in Git clients, which then have their own
                     oddities when interacting with Jujutsu, since it ignores the index.
                  </p>
                  <h3 id="first-class-conflicts" tabindex="-1">
                     <a class="header-anchor" href="#first-class-conflicts"
                        >First-class conflicts</a
                     >
                  </h3>
                  <p>
                     Another huge feature of Jujutsu is its support for
                     <em>first-class conflicts</em>. Instead of a conflict resulting in a
                     nightmare that has to be resolved before you can move on, Jujutsu can
                     incorporate both the merge and its resolution (whether manual or
                     automatic) directly into commit history. Just having the conflicts in
                     history does not seem that weird.<span class="push-double"></span>
                     <span class="pull-double">“</span>Okay, you committed the text
                     conflict markers from git, neat.” But: having the conflict and its
                     resolution in history, especially when Jujutsu figured out how to do
                     that resolution for you, as part of a rebase operation? That is just
                     plain <em>wild</em>.
                  </p>
                  <p>
                     A while back, I was working on a change to
                     <a href="https://github.com/true-myth/true-myth">a library</a> I
                     maintain<sup class="footnote-ref"
                        ><a href="#fn9" id="fnref9">9</a></sup
                     >
                     and decided to flip the order in which I landed two changes to
                     <code>package.json</code>. Unfortunately, those changes were adjacent
                     to each other in the file and so flipping the order they would land
                     in seemed likely to be painfully difficult. It was actually trivial.
                     First of all, the flow itself was great: instead of launching an
                     editor for interactive rebase, I just explicitly told Jujutsu to do
                     the rebases:
                     <code
                        >jj rebase --revision &lt;source&gt; --destination
                        &lt;target&gt;</code
                     >. I did that for each of the items I wanted to reorder and I was
                     done. (I could also have rebased a whole series of commits; I just
                     did not need to in this case.) Literally, that was it: because
                     Jujutsu had agreed with me that <abbr>JSON</abbr> is a terrible
                     format for changes like this and committed a merge conflict, then
                     <em>resolved</em> the merge conflict via the next rebase command, and
                     simply carried on.
                  </p>
                  <p>
                     At a mechanical level, Jujutsu will add conflict markers to a file,
                     not unlike those Git adds in merge conflicts. However, unlike Git,
                     those are not just markers in a file. They are part of a system which
                     understands what conflicts are semantically, and therefore also what
                     <em>resolving</em> a conflict is semantically. This not only produces
                     nice automatic outcomes like the one I described with my library
                     above; it also means that you have more options for how to accomplish
                     a resolution, and for how to treat a conflict. Git trains you to see
                     a conflict between two branches as a problem. It requires you to
                     solve that problem before moving on. Jujutsu <em>allows</em> you to
                     treat a conflict as a problem which much be resolved, but it does not
                     <em>require</em> it. Resolving conflicts in merges in Git is often
                     quite messy. It is even worse when rebasing. I have spent an
                     incredibly amount of time attempting merges only to give up and
                     <code>git reset --hard &lt;before the merge&gt;</code>, and possibly
                     even more time trying to resolve a conflicting in a rebase only to
                     bail with <code>git rebase --abort</code>. Jujutsu allows you to
                     create a merge, leave the conflict in place, and then introduce a
                     resolution in the <em>next</em> commit, telling the whole story with
                     your change history.
                  </p>
                  <figure>
                     <script
                        async=""
                        id="asciicast-Uyfv9qcPTfVeNyoVCINpq5Qfq"
                        src="https://asciinema.org/a/Uyfv9qcPTfVeNyoVCINpq5Qfq.js"
                        data-initialized="1"
                     ></script>
                     <div
                        id="asciicast-container-Uyfv9qcPTfVeNyoVCINpq5Qfq"
                        class="asciicast"
                        style="
                           display: block;
                           float: none;
                           overflow: hidden;
                           padding: 0px;
                           margin: 20px 0px;
                        "
                     >
                        <iframe
                           src="https://asciinema.org/a/Uyfv9qcPTfVeNyoVCINpq5Qfq/iframe?"
                           id="asciicast-iframe-Uyfv9qcPTfVeNyoVCINpq5Qfq"
                           name="asciicast-iframe-Uyfv9qcPTfVeNyoVCINpq5Qfq"
                           scrolling="no"
                           allowfullscreen="true"
                           style="
                              overflow: hidden;
                              margin: 0px;
                              border: 0px;
                              display: inline-block;
                              width: 100%;
                              float: none;
                              visibility: visible;
                              height: 628px;
                           "
                        ></iframe>
                     </div>
                     <figcaption>Conflict resolution with merges</figcaption>
                  </figure>
                  <p>
                     Likewise with a rebase: depending on whether you require all your
                     intermediate revisions to be able to be built or would rather show a
                     history including conflicts, you could choose to rebase, leave all
                     the intermediate changes conflicted, and resolve it only at the end.
                  </p>
                  <figure>
                     <script
                        async=""
                        id="asciicast-k5pFEM07wX1F9ZxcQsLnMTGCd"
                        src="https://asciinema.org/a/k5pFEM07wX1F9ZxcQsLnMTGCd.js"
                        data-initialized="1"
                     ></script>
                     <div
                        id="asciicast-container-k5pFEM07wX1F9ZxcQsLnMTGCd"
                        class="asciicast"
                        style="
                           display: block;
                           float: none;
                           overflow: hidden;
                           padding: 0px;
                           margin: 20px 0px;
                        "
                     >
                        <iframe
                           src="https://asciinema.org/a/k5pFEM07wX1F9ZxcQsLnMTGCd/iframe?"
                           id="asciicast-iframe-k5pFEM07wX1F9ZxcQsLnMTGCd"
                           name="asciicast-iframe-k5pFEM07wX1F9ZxcQsLnMTGCd"
                           scrolling="no"
                           allowfullscreen="true"
                           style="
                              overflow: hidden;
                              margin: 0px;
                              border: 0px;
                              display: inline-block;
                              width: 100%;
                              float: none;
                              visibility: visible;
                              height: 628px;
                           "
                        ></iframe>
                     </div>
                     <figcaption>Conflict resolution with rebases</figcaption>
                  </figure>
                  <p>
                     Conflicts are inevitable when you have enough people working on a
                     repository. Honestly: conflicts happen when I am working
                     <em>alone</em> in a repository, as suggested by my anecdote above.
                     Having this ability to keep working with the repository even in a
                     conflicted state, as well as to resolve the conflicts in a more
                     interactive and iterative way is something I now find difficult to
                     live without.
                  </p>
                  <h3 id="changing-changes" tabindex="-1">
                     <a class="header-anchor" href="#changing-changes"
                        >Changing changes</a
                     >
                  </h3>
                  <p>
                     There are a few other niceties which fall out of Jujutsu’s
                     distinction between changes and commits, especially when combined
                     with first-class conflicts.
                  </p>
                  <p>
                     First up, <code>jj squash</code> takes all the changes in a given
                     commit and, well, <em>squashes</em> them into the parent of that
                     commit.<sup class="footnote-ref"
                        ><a href="#fn10" id="fnref10">10</a></sup
                     >
                     Given a working copy with a bunch of changes, you can move them
                     straight into the parent by just typing <code>jj squash</code>. If
                     you want to squash some change besides the one you are currently
                     editing, you just pass the <code>-r</code>/<code>--revision</code>
                     flag, as with most Jujutsu commands:
                     <code>jj squash -r abc</code> will squash the change identified by
                     <code>abc</code> into its parent. You can also use the
                     <code>--interactive</code> (<code>-i</code> for short) argument to
                     move just a part of a change into its parent. Using that flag will
                     pop up your configured diff editor just like
                     <code>jj split</code> will and allow you to select which items you
                     want to move into the parent and which you want to keep separate. Or,
                     for an even faster option, if you have specific files to move while
                     leaving others alone, and you do not need to handle subsections of
                     those files, you can pass them as the final arguments to the command,
                     like <code>jj squash ./path/a ./path/c</code>.
                  </p>
                  <p>
                     As it turns out, this ability to move part of one change into a
                     different change is a really useful thing to be able to do in
                     general. I find it particularly handy when building up a set of
                     changes where I want each one to be coherent — say, for the sake of
                     having a commit history which is easy for others to review. You
                     <em>could</em> do that by doing some combination of
                     <code>jj split</code> and
                     <code>jj new --after &lt;some change ID&gt;</code> and then doing
                     <code>jj rebase</code> to move around the changes… but as usual,
                     Jujutsu has a better way. The <code>squash</code> command is actually
                     just a shortcut for Jujutsu’s <code>move</code> command with some
                     arguments filled in. The <code>move</code> command has
                     <code>--from</code> and <code>--to</code> arguments which let you
                     specify which revisions you want to move between. When you run
                     <code>jj squash</code> with no other arguments, that is the
                     equivalent of <code>jj move --from @ --to @-</code>. When you run
                     <code>jj squash -r abc</code>, that is the equivalent of
                     <code>jj move --from abc --to abc-</code>. Since it takes those
                     arguments explicitly, though, <code>move</code> lets you move changes
                     around between <em>any</em> changes. They do not need to be anywhere
                     near each other in history.
                  </p>
                  <figure>
                     <script
                        async=""
                        id="asciicast-634399"
                        src="https://asciinema.org/a/634399.js"
                        data-initialized="1"
                     ></script>
                     <div
                        id="asciicast-container-634399"
                        class="asciicast"
                        style="
                           display: block;
                           float: none;
                           overflow: hidden;
                           padding: 0px;
                           margin: 20px 0px;
                        "
                     >
                        <iframe
                           src="https://asciinema.org/a/634399/iframe?"
                           id="asciicast-iframe-634399"
                           name="asciicast-iframe-634399"
                           scrolling="no"
                           allowfullscreen="true"
                           style="
                              overflow: hidden;
                              margin: 0px;
                              border: 0px;
                              display: inline-block;
                              width: 100%;
                              float: none;
                              visibility: visible;
                              height: 573px;
                           "
                        ></iframe>
                     </div>
                     <figcaption>A demo of using <code>jj move</code></figcaption>
                  </figure>
                  <p>
                     This eliminates another entire category of places I have historically
                     had to reach for <code>git rebase --interactive</code>. While there
                     are still a few times where I think Jujutsu could use something akin
                     to Git’s interactive rebase mode, they are legitimately <em>few</em>,
                     and mostly to do with wanting to be able to do batch reordering of
                     commits. To be fair, though, I only want to do that perhaps a few
                     times a year.
                  </p>
                  <h3 id="branches" tabindex="-1">
                     <a class="header-anchor" href="#branches">Branches</a>
                  </h3>
                  <p>
                     Branches are another of the very significant differences between
                     Jujutsu and Git — another place where Jujutsu acts a bit more like
                     Mercurial, in fact. In Git, everything happens on named branches. You
                     <em>can</em> operate on anonymous branches in Git, but it will yell
                     at you constantly about being on a<span class="push-double"></span>
                     <span class="pull-double">“</span>detached <code>HEAD</code
                     ><span class="push-double"></span><span class="pull-double">”</span>.
                     Jujutsu inverts this. The normal working mode in Jujutsu is just to
                     make a series of changes, which then naturally form<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>branches” in the change graph, but
                     which do not require a name out of the gate. You can give a branch a
                     name any time, using <code>jj branch create</code>. That name is just
                     a pointer to the change you pointed it at, though; it does not
                     automatically<span class="push-double"></span>
                     <span class="pull-double">“</span>follow” you as you do
                     <code>jj new</code> to create new changes. (Readers familiar with
                     Mercurial may recognize that this is very similar to its
                     <a href="https://wiki.mercurial-scm.org/Bookmarks">bookmarks</a>),
                     though without the notion of<span class="push-double"></span>
                     <span class="pull-double">“</span>active” and<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>inactive” bookmarks.)
                  </p>
                  <p>
                     To update what a branch name points to, you use the
                     <code>branch set</code> command. To completely get rid of a branch,
                     including removing it from any remotes you have pushed the branch to,
                     you use the <code>branch delete</code> command. Handily, if you want
                     to forget all your <em>local</em> branch operations (though not the
                     changes they apply to), you can use the
                     <code>branch forget</code> command. That can come in useful when your
                     local copy of a branch has diverged from what is on the remote and
                     you don’t want to reconcile the changes and just want to get back to
                     whatever is on the remote for that branch. No need for
                     <code>git reset --hard origin/&lt;branch name&gt;</code>, just
                     <code>jj branch forget &lt;branch name&gt;</code> and then the next
                     time you pull from the remote, you will get back its view of the
                     branch!
                  </p>
                  <figure class="embed">
                     <div class="embed__wrapper">
                        <iframe
                           class="embed__content"
                           src="https://social.jvns.ca/@b0rk/111851540697408119/embed"
                           allowfullscreen="allowfullscreen"
                           sandbox="allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox allow-forms"
                        ></iframe>
                     </div>
                     <figcaption>It’s not just me who wants this!</figcaption>
                  </figure>
                  <p>
                     Jujutsu’s defaulting to anonymous branches took me a bit to get used
                     to, after a decade of doing all of my work in Git and of necessity
                     having to do my work on named branches. As with so many things about
                     Jujutsu, though, I have very much come to appreciate this default. In
                     particular,I find this approach makes really good sense for all the
                     steps where I am not yet sharing a set of changes with others. Even
                     once I <em>am</em> sharing the changes with others, Git’s requirement
                     of a branch name can start to feel kind of silly at times. Especially
                     for the case where I am making some small and self-contained change,
                     the name of a given branch is often just some short,
                     <a href="https://en.wikipedia.org/wiki/Snake_case">snake-case</a
                     >-ified version of the commit message. The default log template shows
                     me the current set of branches, and their commit messages are usually
                     sufficiently informative that I do not need anything else.
                  </p>
                  <p>
                     However, there are some downsides to this approach in practice, at
                     least given today’s ecosystem. First, the lack of a<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>current branch”&nbsp;makes for some
                     extra friction when working with tools like GitHub, GitLab, Gitea,
                     and so on. The GitHub model (which other tools have copied) treats
                     branches as the basis for all work. GitHub displays warning messages
                     about commits which are not on a branch, and will not allow you to
                     create a pull request from an anonymous branch. In many ways, this is
                     simply because Git itself treats branches as special and important.
                     GitHub is just following Git’s example of loud warnings about being
                     on a<span class="push-double"></span>
                     <span class="pull-double">“</span>detached <code>HEAD</code
                     ><span class="push-double"></span
                     ><span class="pull-double">”</span> commit, after all.
                  </p>
                  <p>
                     What this means in practice, though, is that there is an extra
                     operation required any time you want to push your changes to GitHub
                     or a similar forge. With Git, you simply <code>git push</code> after
                     making your changes. (More on Git interop below.) Since Git keeps the
                     current branch pointing at the current <code>HEAD</code>, Git aliases
                     <code>git push</code> with no arguments to
                     <code
                        >git push &lt;configured remote for current branch&gt; &lt;current
                        branch&gt;</code
                     >. Jujutsu does not do this, and given how its branching model works
                     today, <em>cannot</em> do this, because named branches do not<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>follow” your operations. Instead,
                     you must first explicitly set the branch to the commit you want to
                     push. In the most common case, where you are pushing your latest set
                     of changes, that is just
                     <code>jj branch set &lt;branch name&gt;</code>; it takes the current
                     change automatically. Only then can you run
                     <code>jj git push</code> to actually get an update. This is only a
                     paper cut, but it is a paper cut. It is one extra command every
                     single time you go to push a change to share with others, or even
                     just to get it off of your machine.<sup class="footnote-ref"
                        ><a href="#fn11" id="fnref11">11</a></sup
                     >
                     That might not seem like a lot, but it adds up.
                  </p>
                  <p>
                     There is a real tension in the design space here, though. On the one
                     hand, the main time I use branches in Jujutsu at this point is for
                     pushing to a Git forge like GitHub. I rarely feel the need for them
                     for just working on a set of changes, where <code>jj log</code> and
                     <code>jj new &lt;some revision&gt;</code> give me everything I need.
                     In that sense, it seems like having the branch<span
                        class="push-double"
                     ></span>
                     <span class="pull-double">“</span>follow along” with my work would be
                     natural: if I have gone to the trouble of creating a name for a
                     branch and pushing it to some remote, then it is very likely I want
                     to keep it up to date as I add changes to the branch I named. On the
                     other hand, there is a big upside to not doing that automatically:
                     pushing changes becomes an intentional act. I cannot count the number
                     of times I have been working on what is essentially just an
                     experiment in a Git repo, forgotten to change from the
                     <code>foo-feature</code> to a new
                     <code>foo-feature-experiment</code> branch, and then done a
                     <code>git push</code>. Especially if I am collaborating with others
                     on <code>foo-feature</code>, now I have to force push back to the
                     previous to reset things, and let others know to wait for that, etc.
                     That never happens with the Jujutsu model. Since updating a named
                     branch is always an intentional act, you can experiment to your
                     heart’s content, and know you will never <em>accidentally</em> push
                     changes to a branch that way. I go back and forth: Maybe the little
                     bit of extra friction when you <em>do</em> want to push a branch is
                     worth it for all the times you do not have to consciously move a
                     branch backwards to avoid pushing changes you are not yet ready to
                     share.
                  </p>
                  <p>
                     (As you might expect, the default of anonymous branches has some
                     knock-on effects for how it interacts with Git tooling in general; I
                     say more on this below.)
                  </p>
                  <p>
                     Jujutsu also has a handy little feature for when you have done a
                     bunch of work on an anonymous branch and are ready to push it to a
                     Git forge. The <code>jj git push</code> subcommand takes an optional
                     <code>--change</code>/<code>-c</code> flag, which creates a branch
                     based on your current change <abbr title="identifier">ID</abbr>. It
                     works really well when you only have a single change you are going to
                     push and then continually work on, or any time you are content that
                     your current change will remain the tip of the branch. It works a
                     little <em>less</em> well when you are going to add further changes
                     later, because you need to then actually use the branch name with
                     <code>jj branch set push/&lt;change ID&gt; -r &lt;revision&gt;</code
                     >.
                  </p>
                  <p>
                     Taking a step back, though, working with branches in Jujutsu is
                     <em>great</em> overall. The <code>branch</code> command is a
                     particularly good lens for seeing what a well-designed
                     <abbr title="command line interface">CLI</abbr> is like and how it
                     can make your work easier. Notice that the various commands there are
                     all of the form <code>jj branch &lt;do something&gt;</code>. There
                     are a handful of other <code>branch</code> subcommands not mentioned
                     so far: <code>list</code>, <code>rename</code>, <code>track</code>,
                     and <code>untrack</code>. Git has slowly improved its design here
                     over the past few years, but still lacks the straightforward
                     coherence of Jujutsu’s design. For one thing, all of these are
                     <em>subcommands</em> in Jujutsu, not like Git’s mishmash of flags
                     which can be combined in some cases but not others, and have
                     different meanings depending on where they are deployed. For another,
                     as with the rest of Jujutsu’s
                     <abbr title="command line interface">CLI</abbr> structure, they use
                     the same options to mean the same things. If you want to list all the
                     branches which point to a given set of revisions, you use the
                     <code>-r</code>/<code>--revisions</code> flag, exactly like you do
                     with any other command involving revisions in Jujutsu. In general,
                     Jujutsu has a very strong and careful distinction between
                     <em>commands</em> (including subcommands) and <em>options</em>. Git
                     does not. The <code>track</code> and <code>untrack</code> subcommands
                     are a perfect example. In Jujutsu, you track a remote branch by
                     running a command like
                     <code>jj branch track &lt;branch&gt;@&lt;remote&gt;</code>. The
                     corresponding Git command is
                     <code
                        >git branch --set-upstream-to &lt;remote&gt;/&lt;branch&gt;</code
                     >. But to <em>list and filter</em> branches in Git, you also pass
                     flags, e.g. <code>git branch --all</code> is the equivalent of
                     <code>jj branch list --all</code>. The Git one is shorter, but also
                     notably less coherent; there is no way to build a mental model for
                     it. With Jujutsu, the mental model is obvious and consistent:
                     <code>jj &lt;command&gt; &lt;options&gt;</code> or
                     <code>jj &lt;context&gt; &lt;command&gt; &lt;options&gt;</code>,
                     where <code>&lt;context&gt;</code> is something like
                     <code>branch</code> or <code>workspace</code> or <code>op</code> (for
                     operation).
                  </p>
                  <h3 id="git-interop" tabindex="-1">
                     <a class="header-anchor" href="#git-interop">Git interop</a>
                  </h3>
                  <p>
                     Jujutsu’s native back end exists, and every feature has to work with
                     it, so it will some day be a real feature of the <abbr>VCS</abbr>.
                     Today, though, the Git backend is the only one you should use. So
                     much so that if you try to run <code>jj init</code> without passing
                     <code>--git</code>, Jujutsu won’t let you by default:
                  </p>
                  <pre><code class="language-sh">&gt; jj init
           Error: The native backend is disallowed by default.
           Hint: Did you mean to pass `--git`?
           Set `ui.allow-init-native` to allow initializing a repo with the native backend.
           </code></pre>
                  <p>
                     In practice, you are going to be using the Git backend. In practice,
                     I have been using the Git backend for the last seven months, full
                     time, on every one of my personal repositories and all the open
                     source projects I have contributed to. With the sole exception of
                     someone watching me while we pair, no one has noticed, because the
                     Git integration is that solid and robust. This interop means that
                     adoption can be very low friction. Any individual can simply run
                     <code>jj init --git-repo .</code> in a given Git repository, and
                     start doing their work with Jujutsu instead of Git, and all that work
                     gets translated directly into operations on the Git repository.
                  </p>
                  <p>
                     Interoperating with Git also means that there is a two way-street
                     between Jujutsu and Git. You can do a bunch of work with
                     <code>jj</code> commands, and then if you hit something you don’t
                     know how to do with Jujutsu yet, you can flip over and do it the way
                     you already know with a <code>git</code> command. When you next run a
                     <code>jj</code> command, like <code>jj status</code>, it will (very
                     quickly!) import the updates from Git and go back about its normal
                     business. The same thing happens when you run commands like
                     <code>jj git fetch</code> to get the latest updates from a Git
                     remote. All the explicit Git interop commands live under a
                     <code>git</code> subcommand: <code>jj git push</code>,
                     <code>jj git fetch</code>, etc. There are a handful of these,
                     including the ability to explicitly ask to synchronize with the Git
                     repository, but the only ones I use on a day to day basis are
                     <code>jj git push</code> and <code>jj git fetch</code>. Notably,
                     there is no <code>jj git pull</code>, because Jujutsu keeps a
                     distinction between getting the latest changes from the server and
                     changing your local copy’s state. I have not missed
                     <code>git pull</code> at all.
                  </p>
                  <p>
                     This clean interop does <em>not</em> mean that Git sees everything
                     Jujutsu sees, though. Initializing a Jujutsu repo adds a
                     <code>.jj</code> directory to your project, which is where it stores
                     its extra metadata. This, for example, is where Jujutsu keeps track
                     of its own representation of changes, including how any given change
                     has evolved, in terms of the underlying revisions. In the case of a
                     Git repository, those revisions just are the Git commits, and
                     although you rarely <em>need</em> to work with or name them directly,
                     they have the same <abbr title="secure hash algorithm">SHA</abbr>s,
                     so any time you would name a specific Git commit, you can reference
                     it directly as a Jujutsu revision as well. (This is particularly
                     handy when bouncing between <code>jj</code> commands and Git-aware
                     tools which know nothing of Jujutsu’s change identifiers.) The
                     <code>.jj</code> directory also includes the operation log, and in
                     the case of a fresh Jujutsu repo (not one created from an existing
                     Git repository), is where the backing Git repo lives.
                  </p>
                  <p>
                     This Git integration currently runs on <code>libgit2</code>, so there
                     is effectively no risk of breaking your repo because of a
                     <dash-wrap>Jujutsu – Git</dash-wrap> interop issue. To be sure, there
                     can be bugs in Jujutsu itself, and you can do things using Jujutsu
                     that will leave you in a bit of a mess, but the same is true of
                     <em>any</em> tool which works on your Git repository. The risk might
                     be very slightly higher here than with your average
                     <abbr>GUI</abbr> Git client, since Jujutsu is mapping different
                     semantics onto the repository, but I have extremely high confidence
                     in the project at this point, and I think you can too.
                  </p>
                  <h3 id="is-it-ready" tabindex="-1">
                     <a class="header-anchor" href="#is-it-ready">Is it ready?</a>
                  </h3>
                  <p>
                     Unsurprisingly, given the scale of the problem domain, there are
                     still some rough edges and gaps. For example: commit signing with
                     <abbr title="GNU Privacy Guard">GPG</abbr> or
                     <abbr title="secure shell">SSH</abbr> does not yet work. There is an
                     open <abbr title="pull request">PR</abbr> for the basics of the
                     feature with <abbr title="GNU Privacy Guard">GPG</abbr> support, and
                     <abbr title="secure shell">SSH</abbr> support will be straightforward
                     to add once the basics, but landed it has not.<sup
                        class="footnote-ref"
                        ><a href="#fn12" id="fnref12">12</a></sup
                     >
                     The list of actual gaps or missing features is getting short, though.
                     When I started using Jujutsu back in July 2023, there was not yet any
                     support for sparse checkouts or for workspaces (analogous to Git
                     worktrees). Both of those landed in the interval, and there is
                     consistent forward motion from both Google and non-Google
                     contributors. In fact, the biggest gap I see as a regular user in
                     Jujutsu itself is the lack of the kinds of capabilities that will
                     hopefully come once work starts in earnest on the native back end.
                  </p>
                  <p>
                     The real gaps and rough edges at this point are down to the lack of
                     an ecosystem of tools around Jujutsu, and the ways that existing Git
                     tools interact with Jujutsu’s design for Git interop. The lack of
                     tooling is obvious: no one has built the equivalent of
                     <a href="https://git-fork.com">Fork</a> or
                     <a href="https://www.git-tower.com/mac">Tower</a>, and there is no
                     native integration in
                     <abbr title="integrated development environment">IDE</abbr>s like
                     IntelliJ or Visual Studio or in editors like
                     <abbr title="Visual Studio">VS</abbr> Code or Vim. Since Jujutsu
                     currently works primarily in terms of Git, you will get
                     <em>some</em> useful feedback. All of those tools expect to be
                     working in terms of Git’s index and not in terms of a Jujutsu-style
                     working copy, though. Moreover, most of them (unsurprisingly!) share
                     Git’s own confusion about why you are working on a detached
                     <code>HEAD</code> nearly all the time. On the upside, viewing the
                     history of a repo generally works well, with the exception that some
                     tools will not show anonymous branches/detached <code>HEAD</code>s
                     other than one you have actively checked out. Detached heads also
                     tend to confuse tools like GitHub’s <code>gh</code>; you will often
                     need to do a bit of extra manual argument-passing to get them to
                     work. (<code>gh pr create --web --head &lt;name&gt;</code>
                     is has been showing up in my history a lot for exactly this reason.)
                  </p>
                  <p>
                     Some of Jujutsu’s very nice features also make other parts of working
                     on mainstream Git forges a bit wonky. For example, notice what each
                     of these operations has in common:
                  </p>
                  <ul>
                     <li>Inserting changes at arbitrary points.</li>
                     <li>Rewording a change description.</li>
                     <li>Rebasing a series of changes.</li>
                     <li>Splitting apart commits.</li>
                     <li>Combining existing commits.</li>
                  </ul>
                  <p>
                     They are all changes to history. If you have pushed a branch to a
                     remote, doing any of these operations with changes on that branch and
                     pushing to a remote again will be a <em>force push</em>. Most
                     mainstream Git forges handle force pushing pretty badly. In
                     particular, GitHub has some support for showing diffs between force
                     pushes, but it is very basic and loses all conversational context. As
                     a result, any workflow which makes heavy use of force pushes will be
                     bumpy. Jujutsu is not to blame for the gaps in those tools, but it
                     certainly does expose them.<sup class="footnote-ref"
                        ><a href="#fn13" id="fnref13">13</a></sup
                     >
                     Nor do I not blame GitHub for the quirks in interop, though. It is
                     not JujutsuLab after all, and Jujutsu is doing things which do not
                     perfectly map onto the Git model. Since most open source software
                     development happens on forges like GitHub and GitLab, though, these
                     things do regularly come up and cause some friction.
                  </p>
                  <p>
                     The biggest place I feel this today is in the lack of tools designed
                     to work with Jujutsu around splitting, moving, and otherwise
                     interactively editing changes. Other than
                     <a href="https://github.com/arxanas">@arxanas</a
                     ><span class="push-single"></span
                     ><span class="pull-single">’</span> excellent
                     <code>scm-diff-editor</code>, the
                     <abbr title="text user interface">TUI</abbr>, which Jujutsu bundles
                     for editing diffs on the command line, there are zero
                     <em>good</em> tools for those operations. I mean it when I say
                     <code>scm-diff-editor</code> is excellent, but I also do not love
                     working in a <abbr title="text user interface">TUI</abbr> for this
                     kind of thing, so I have cajoled both
                     <a href="https://kaleidoscope.app">Kaleidoscope</a> and BBEdit into
                     working to some degree. As I noted when describing how
                     <code>jj split</code> works, though, it is not a particularly good
                     experience. These tools are simply not designed for this workflow.
                     They understand an index, and they do not understand splitting apart
                     changes. Net, we are going to want new tooling which actually
                     understands Jujutsu.
                  </p>
                  <p>
                     There are opportunities here beyond implementing the same kinds of
                     capabilities that <em>many</em> editors,
                     <abbr title="integrated development environment">IDE</abbr>s, and
                     dedicated <abbr title="version control system">VCS</abbr> viewers
                     provide today for Git. Given a tool which makes rebasing, merging,
                     re-describing changes, etc. are all normal and easy operations,
                     <abbr title="graphical user interface">GUI</abbr> tools could make
                     all of those much easier. Any number of the Git
                     <abbr title="graphical user interface">GUI</abbr>s have tried, but
                     Git’s underlying model simply makes it clunky. That does not have to
                     be the case with Jujutsu. Likewise, surfacing things like Jujutsu’s
                     operation and change evolution logs should be much easier than
                     surfacing the Git reflog, and provide easier ways to recover lost
                     work or simply to change one’s mind.
                  </p>
                  <h2 id="conclusion" tabindex="-1">
                     <a class="header-anchor" href="#conclusion">Conclusion</a>
                  </h2>
                  <p>
                     Jujutsu has become my version control tool of choice since I picked
                     it up over the summer. The rough edges and gaps I described
                     throughout this write-up notwithstanding, I <em>much</em> prefer it
                     to working with Git directly. I do not hesitate to recommend that you
                     try it out on personal or open source projects. Indeed, I actively
                     recommend it! I have used Jujutsu almost exclusively for the past
                     seven months, and I am not sure what would make me go back to using
                     Git other than Jujutsu being abandoned entirely. Given its
                     apparently-bright future at Google, that seems unlikely.<sup
                        class="footnote-ref"
                        ><a href="#fn14" id="fnref14">14</a></sup
                     >
                     Moreover, because using it in existing Git repositories is
                     transparent, there is no inherent reason individual developers or
                     teams cannot use it today. (Your corporate security policy might have
                     be a different story.)
                  </p>
                  <p>
                     Is Jujutsu ready for you to roll out at your Fortune 500 company?
                     Probably not. While it is improving at a steady clip — most of the
                     rough edges I hit in mid-2023 are long since fixed — it is still
                     undergoing breaking changes in design here and there, and there is
                     effectively no material out there about how to use it yet. (This
                     essay exists, in part, as an attempt to change that!) Beyond Jujutsu
                     itself, there is a lot of work to be done to build an ecosystem
                     around it. Most of the remaining rough edges are squarely to do with
                     the lack of understanding from other tools. The project is marching
                     steadily toward a 1.0 release… someday. As for when that might be,
                     there are as far as I know no plans: there is still too much to do.
                     Above all, I am very eager to see what a native Jujutsu backend would
                     look like. Today, it is<span class="push-double"></span>
                     <span class="pull-double">“</span>just” a much better model for
                     working with Git repos. A world where the same level of smarts being
                     applied to the front end goes into the back end too is a world well
                     worth looking forward to.
                  </p>
                  <section class="callout" aria-role="note">
                     <p>Thoughts, comments, or questions? Discuss:</p>
                     <ul>
                        <li>
                           <a href="https://news.ycombinator.com/item?id=39232456"
                              >Hacker News</a
                           >
                        </li>
                        <li>
                           <a href="https://lobste.rs/s/pvvbhm/jj_init">lobste.rs</a>
                        </li>
                        <li>
                           <a
                              href="https://www.linkedin.com/feed/update/urn:li:activity:6923287174180212736/"
                              >LinkedIn</a
                           >
                        </li>
                        <li>
                           <a
                              href="https://mastodon.social/@chriskrycho/111863369362392797"
                              >Mastodon</a
                           >
                        </li>
                        <li>
                           <a href="https://www.threads.net/@chriskrycho/post/C22w19OgBJV"
                              >Threads</a
                           >
                        </li>
                        <li>
                           <a
                              href="https://bsky.app/profile/chriskrycho.com/post/3kkhe5pxuek27"
                              >Bluesky</a
                           >
                        </li>
                        <li>
                           <a
                              href="https://twitter.com/chriskrycho/status/1753489910600712246?s=20"
                              >Twitter/X</a
                           >
                        </li>
                     </ul>
                  </section>
                  <h2 id="appendix-kaleidoscope-setup-and-tips" tabindex="-1">
                     <a class="header-anchor" href="#appendix-kaleidoscope-setup-and-tips"
                        >Appendix: Kaleidoscope setup and tips</a
                     >
                  </h2>
                  <p>
                     As alluded to above, I have done my best to make it possible to use
                     <a href="https://kaleidoscope.app">Kaleidoscope</a>, my beloved
                     diff-and-merge tool, with Jujutsu. I have had only mixed success. The
                     appropriate setup that gives the best results so far:
                  </p>
                  <ol>
                     <li>
                        <p>
                           Add the following to your Jujutsu config (<code
                              >jj config edit --user</code
                           >) to configure Kaleidoscope for the various diff and merge
                           operations:
                        </p>
                        <pre><code class="language-toml"><span class="hljs-section">[ui]</span>
           <span class="hljs-attr">diff-editor</span> = [<span class="hljs-string">"ksdiff"</span>, <span class="hljs-string">"--wait"</span>, <span class="hljs-string">"$left"</span>, <span class="hljs-string">"--no-snapshot"</span>, <span class="hljs-string">"$right"</span>, <span class="hljs-string">"--no-snapshot"</span>]
           <span class="hljs-attr">merge-editor</span> = [<span class="hljs-string">"ksdiff"</span>, <span class="hljs-string">"--merge"</span>, <span class="hljs-string">"--output"</span>, <span class="hljs-string">"$output"</span>, <span class="hljs-string">"--base"</span>, <span class="hljs-string">"$base"</span>, <span class="hljs-string">"--"</span>, <span class="hljs-string">"$left"</span>, <span class="hljs-string">"--snapshot"</span>, <span class="hljs-string">"$right"</span>, <span class="hljs-string">"--snapshot"</span>]
           </code></pre>
                        <p>
                           I will note, however, that I have still not been 100%
                           successful using Kaleidoscope this way. In particular,
                           <code>jj split</code> does not give me the desired results; it
                           often ends up reporting<span class="push-double"></span>
                           <span class="pull-double">“</span>Nothing changed” when I close
                           Kaleidoscope.
                        </p>
                     </li>
                     <li>
                        <p>
                           When opening a <em>file</em> diff, you must <kbd>Option</kbd
                           ><kbd>⎇</kbd>-double-click, <em>not</em> do a normal
                           double-click, so that it will preserve the
                           <code>--no-snapshot</code> behavior. That
                           <code>--no-snapshot</code> argument to <code>ksdiff</code> is
                           what makes the resulting diff editable, which is what Jujutsu
                           needs for its just-edit-a-diff workflow. I have been in touch
                           with the Kaleidoscope folks about this, which is how I even
                           know about this workaround; they are evaluating whether it is
                           possible to make the normal double-click flow preserve the
                           <code>--no-snapshot</code> in this case so you do not
                           <em>have</em> to do the workaround.
                        </p>
                     </li>
                  </ol>
                  <hr class="footnotes-sep" />
                  <section class="footnotes">
                     <h2 id="footnotes">
                        <a class="header-anchor" href="#footnotes">Notes</a>
                     </h2>
                     <ol class="footnotes-list">
                        <li id="fn1" class="footnote-item">
                           <p>
                              Yes, it is written in Rust, and it is pretty darn fast. But
                              Git is written in C, and is <em>also</em> pretty darn fast.
                              There are of course some safety upsides to using Rust here,
                              but Rust is not particularly core to Jujutsu’s<span
                                 class="push-double"
                              ></span>
                              <span class="pull-double">“</span>branding”. It was just a
                              fairly obvious choice for a project like this at this
                              point — which is exactly what I have long hoped Rust would
                              become! <a href="#fnref1" class="footnote-backref">↩︎</a>
                           </p>
                        </li>
                        <li id="fn2" class="footnote-item">
                           <p>
                              Pro tip for Mac users: add <code>.DS_Store</code> to your
                              <code>~/.gitignore_global</code> and live a much less
                              annoyed life — whether using Git or Jujutsu.
                              <a href="#fnref2" class="footnote-backref">↩︎</a>
                           </p>
                        </li>
                        <li id="fn3" class="footnote-item">
                           <p>
                              I did have
                              <a href="https://github.com/martinvonz/jj/issues/1794"
                                 >one odd hiccup</a
                              >
                              along the way due to a bug (already fixed, though not in a
                              released version) in how Jujutsu handles a failure when
                              initializing in a directory. While confusing, the problem
                              was fixed in the next release… and this is what I expected
                              of still-relatively-early software.
                              <a href="#fnref3" class="footnote-backref">↩︎</a>
                           </p>
                        </li>
                        <li id="fn4" class="footnote-item">
                           <p>
                              This is not quite the same as Git’s <code>HEAD</code> or as
                              Mercurial’s<span class="push-double"></span>
                              <span class="pull-double">“</span>tip” — there is only one
                              of either of those, and they are not the same as each other!
                              <a href="#fnref4" class="footnote-backref">↩︎</a>
                           </p>
                        </li>
                        <li id="fn5" class="footnote-item">
                           <p>
                              If you look at the <code>jj help</code> output today, you
                              will notice that Jujutsu has <code>checkout</code>,
                              <code>merge</code>, and <code>commit</code> commands. Each
                              is just an alias for a behavior using <code>new</code>,
                              <code>describe</code>, or both, though:
                           </p>
                           <ul>
                              <li>
                                 <code>checkout</code> is just an alias for
                                 <code>new</code>
                              </li>
                              <li>
                                 <code>commit</code> is just a shortcut for
                                 <code
                                    >jj describe -m "&lt;some message&gt;" &amp;&amp; jj
                                    new</code
                                 >
                              </li>
                              <li>
                                 <code>merge</code> is just <code>jj new</code> with an
                                 implicit <code>@</code> as the first argument.
                              </li>
                           </ul>
                           <p>
                              All of these are going to go away in the medium term with
                              both documentation and output from the
                              <abbr title="command line interface">CLI</abbr> that teach
                              people to use <code>new</code> instead.
                              <a href="#fnref5" class="footnote-backref">↩︎</a>
                           </p>
                        </li>
                        <li id="fn6" class="footnote-item">
                           <p>
                              Actually it is normally
                              <code>git ci -am "&lt;message&gt;"</code> with
                              <code>-a</code> for<span class="push-double"></span>
                              <span class="pull-double">“</span>all” (<code>--all</code>)
                              and <code>-m</code> for the message, and smashed together to
                              avoid any needless extra typing.
                              <a href="#fnref6" class="footnote-backref">↩︎</a>
                           </p>
                        </li>
                        <li id="fn7" class="footnote-item">
                           <p>
                              The name is from Mercurial’s
                              <a href="https://www.mercurial-scm.org/doc/evolution/"
                                 >evolution</a
                              >
                              feature, where it refers to changes which have become
                              <em>obsolescent</em>, thus <code>obslog</code> is the<span
                                 class="push-double"
                              ></span>
                              <span class="pull-double">“</span>obsolescent changes log”.
                              I recently suggested to the Jujutsu maintainers that
                              renaming this might be helpful, because it took me six
                              months of daily use to discover this incredibly helpful
                              tool.
                              <a href="#fnref7" class="footnote-backref">↩︎</a>
                           </p>
                        </li>
                        <li id="fn8" class="footnote-item">
                           <p>
                              They also enabled support for a three-pane view in
                              <a href="https://meld.app">Meld</a>, which allegedly makes
                              it somewhat better. However, Meld is pretty janky on macOS
                              (as <a href="https://www.gtk.org">GTK</a> apps basically
                              always are), and it has a <em>terrible</em> startup time for
                              reasons that are unclear at this point, which means this was
                              not a great experience in the first place… and Meld
                              <a href="https://github.com/yousseb/meld/issues/147"
                                 >crashes on launch</a
                              >
                              on the current version of macOS.
                              <a href="#fnref8" class="footnote-backref">↩︎</a>
                           </p>
                        </li>
                        <li id="fn9" class="footnote-item">
                           <p>
                              Yes, this is what I do for fun on my time off. At least:
                              partially.
                              <a href="#fnref9" class="footnote-backref">↩︎</a>
                           </p>
                        </li>
                        <li id="fn10" class="footnote-item">
                           <p>
                              For people coming from Git, there is also an
                              <code>amend</code> alias, so you can use
                              <code>jj amend</code> instead, but it does the same thing as
                              <code>squash</code> and in fact the help text for
                              <code>jj amend</code> makes it clear that it just
                              <em>is</em> <code>squash</code>.
                              <a href="#fnref10" class="footnote-backref">↩︎</a>
                           </p>
                        </li>
                        <li id="fn11" class="footnote-item">
                           <p>
                              If that sounds like paranoia, well, you only have to lose
                              everything on your machine once due to someone spilling a
                              whole cup of water on it at a coffee shop to learn to be a
                              bit paranoid about having off-machine backups of everything.
                              I
                              <code>git push</code> all the time.
                              <a href="#fnref11" class="footnote-backref">↩︎</a>
                           </p>
                        </li>
                        <li id="fn12" class="footnote-item">
                           <p>
                              I care about about this feature and have some hopes of
                              helping get it across the line myself here in February 2024,
                              but we will see!
                              <a href="#fnref12" class="footnote-backref">↩︎</a>
                           </p>
                        </li>
                        <li id="fn13" class="footnote-item">
                           <p>
                              There are plenty of interesting arguments out there about
                              the GitHub collaboration design, alternatives represented by
                              the Phabricator or Gerrit review models, and so on. This
                              piece is long enough without them!
                              <a href="#fnref13" class="footnote-backref">↩︎</a>
                           </p>
                        </li>
                        <li id="fn14" class="footnote-item">
                           <p>
                              Google is famous for killing <em>products</em>, but less so
                              developer tools.
                              <a href="#fnref14" class="footnote-backref">↩︎</a>
                           </p>
                        </li>
                     </ol>
                  </section>
               </div>

               <footer class="post-meta">
                  <div class="section-label">Thanks:</div>
                  <div class="section-content">
                     <a href="https://github.com/arxanas">Waleed Khan (@arxanas)</a>,
                     <a href="https://github.com/joyously">Joy Reynolds (@joyously)</a>,
                     and
                     <a href="https://github.com/isinyaaa">Isabella Basso (@isinyaaa)</a>
                     all took time to read and comment on earlier drafts of this mammoth
                     essay, and it is substantially better for their feedback!
                  </div>

                  <div class="section-label">Posted:</div>
                  <div class="section-content">
                     <p>
                        This entry was originally published in
                        <a href="/essays/">Essays</a>
                        on <span class="dt-published">February 2, 2024</span>, and last
                        updated on February 4, 2024 (you can see the full revision history
                        <a
                           href="https://github.com/chriskrycho/v5.chriskrycho.com/commits/main/site%2Fessays%2Fjj%20init.md"
                           >here</a
                        >); it was started on July 1, 2023.
                     </p>
                     <div class="updates">
                        <p><i>Meaningful changes since creating this page:</i></p>
                        <ul>
                           <li>
                              <i>February 4, 2024:</i>
                              Filled out the section on Git interop. (How did I miss that
                              before publishing?!?)
                           </li>
                           <li>
                              <i>February 3, 2024:</i>
                              Added an example of the <code>log</code> format right up
                              front in that section.
                           </li>
                           <li>
                              <i>February 2, 2024:</i>
                              Reworked section on revsets and prepared for publication!
                           </li>
                           <li>
                              <i>February 1, 2024:</i>
                              Finished a draft! Added one and updated another asciinema
                              for some of the basics, finished up the tooling section, and
                              made a bunch of small edits.
                           </li>
                           <li>
                              <i>January 31, 2024:</i>
                              Finished describing first-class conflicts and added
                              asciinema recordings showing conflicts with merges and
                              rebases.
                           </li>
                           <li>
                              <i>January 30, 2024:</i>
                              Added a ton of material on branches and on CLI design.
                           </li>
                           <li>
                              <i>January 29, 2024:</i>
                              Wrote up a section on “changing changes”, focused on the
                              <code>squash</code> and <code>move</code> commands.
                           </li>
                           <li>
                              <i>January 29, 2024:</i>
                              Added a section on <code>obslog</code>, and made sure the
                              text was consistent on use of “Jujutsu” vs.
                              <code>jj</code> for the name of the tool vs. command-line
                              invocations.
                           </li>
                           <li>
                              <i>January 18, 2024:</i>
                              Made some further structural revisions, removing some
                              now-defunct copy about the original plan, expanded on the
                              conclusion, and substantially expanded the conclusion.
                           </li>
                           <li>
                              <i>January 16, 2024:</i>
                              <code>jj init</code> is an essay, and I am rewriting it—not
                              a dev journal, but an essay introduction to the tool.
                           </li>
                           <li>
                              <i>November 2, 2023:</i>
                              Added a first pass at a conclusion, and started on the
                              restructuring this needs.
                           </li>
                           <li>
                              <i>November 1, 2023:</i>
                              Describing a bit about how <code>jj new -A</code> works and
                              integrates with its story for clean rebases.
                           </li>
                           <li>
                              <i>October 31, 2023:</i>
                              Filling in what makes <code>jj</code> interesting, and
                              explaining templates a bit.
                           </li>
                           <li>
                              <i>August 7, 2023:</i>
                              A first pass at <code>jj describe</code> and
                              <code>jj new</code>.
                           </li>
                           <li>
                              <i>August 7, 2023:</i>
                              YODA! And an introduction to the “Rewiring your Git brain”
                              section.
                           </li>
                           <li>
                              <i>August 7, 2023:</i>
                              Adding more structure to the piece, and identifying the next
                              pieces to write.
                           </li>
                           <li>
                              <i>July 31, 2023:</i>
                              Starting to do some work on the introduction.
                           </li>
                           <li>
                              <i>July 24, 2023:</i>
                              Correcting my description of revision behavior per
                              discussion with the maintainer.
                           </li>
                           <li>
                              <i>July 24, 2023:</i>
                              Describing my current feelings about the
                              <code>jj split</code> and auto-committed working copy vs.
                              <code>git add --patch</code> (as mediated by a
                              <abbr>UI</abbr>).
                           </li>
                           <li>
                              <i>July 13, 2023:</i>
                              Elaborated on the development of version control systems
                              (both personally and in general!)… and added a bunch of
                              <code>&lt;abbr&gt;</code> tags.
                           </li>
                           <li>
                              <i>July 12, 2023:</i>
                              Added a section on the experience of having first-class
                              merging Just Work™, added an appendix about Kaleidoscope
                              setup and usage, rewrote the paragraph where I previously
                              mentioned the issues about Kaleidoscope, and iterated on the
                              commit-vs.-change distinction.
                           </li>
                           <li>
                              <i>July 9, 2023:</i>
                              Rewrote the <code>jj log</code> section to incorporate info
                              about revsets, rewrote a couple of the existing sections now
                              that I have significantly more experience, and added a bunch
                              of notes to myself about what to tackle next in this
                              write-up.
                           </li>
                           <li>
                              <i>July 3, 2023:</i>
                              Wrote up some experience notes on actually using
                              <code>jj describe</code> and <code>jj new</code>: this is
                              pretty wild, and I think I like it?
                           </li>
                           <li>
                              <i>July 3, 2023:</i>
                              Reorganized and clarified the existing material a bit.
                           </li>
                           <li>
                              <i>July 2, 2023:</i>
                              Added some initial notes about initial setup bumps. And a
                              <em>lot</em> of notes on the things I learned in trying to
                              fix those!
                           </li>
                        </ul>
                     </div>
                     <p>
                        Spotted a typo?
                        <a
                           href="https://github.com/chriskrycho/v5.chriskrycho.com/edit/main/site%2Fessays%2Fjj%20init.md"
                           >Submit a correction!</a
                        >
                     </p>
                  </div>
                  <div class="section-label">Topics:</div>
                  <ul class="topics section-content">
                     <li class="__topic">
                        <a href="/topics/software-development">software development</a>
                     </li>
                     <li class="__topic"><a href="/topics/tools">tools</a></li>
                     <li class="__topic">
                        <a href="/topics/version-control">version control</a>
                     </li>
                     <li class="__topic"><a href="/topics/jujutsu">Jujutsu</a></li>
                     <li class="__topic"><a href="/topics/git">Git</a></li>
                  </ul>

                  <div class="section-label">Respond:</div>
                  <div class="section-content">
                     <p>
                        Thoughts, comments, or questions?
                        <a href="mailto:hello@chriskrycho.com?subject=Re%3A%20jj%20init"
                           >Shoot me an email</a
                        >
                        (it’s way better than traditional comments), or leave a comment on
                        <a href="https://news.ycombinator.com/item?id=39232456"
                           >Hacker News</a
                        >
                        or <a href="https://lobste.rs/s/pvvbhm/jj_init">lobste.rs</a>.
                     </p>
                  </div>

                  <div class="section-label">About:</div>
                  <div class="section-content">
                     <p>
                        I’m Chris Krycho—a follower of Christ, a husband, and a dad. I’m a
                        <a href="/cv/">software engineer</a> by trade; a theologian by
                        vocation; and a writer,
                        <a href="https://www.strava.com/athletes/chriskrycho"
                           >runner and cyclist</a
                        >,
                        <a href="https://soundcloud.com/chriskrycho/tracks">composer</a>,
                        and erstwhile podcaster by hobby.
                     </p>
                  </div>

                  <div class="section-label">Support:</div>
                  <div class="section-content">
                     <p>
                        If you especially like what I’m doing here, you can
                        <a href="https://buymeacoffee.com/chriskrycho">buy me a book</a>,
                        or click the affiliate links in book reviews!
                     </p>
                  </div>
               </footer>
            </article>
         </main>
      </div>

      <footer>
         <p>
            This is the footer. Some stuff will go in it eventually. Colophon? Nav? Stuff.
         </p>
      </footer>
   </body>
</html>
